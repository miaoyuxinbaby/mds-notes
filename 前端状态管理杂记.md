### no-title
- study from https://zhuanlan.zhihu.com/p/25800767

### Virtual DOM 及 React 诞生
- AngularJS 数据和视图的双向绑定基于脏检测的机制，在性能上存在短板，任何数据的变更都会重绘整个视图。但是，由状态反应视图、自动更新页面的思想是先进的，为了解决性能上的问题，Facebook 的工程师们提出了 Virtual DOM 的思想。将 DOM 放到内存中，state 发生变化的时候，根据 state 生成新的 Virtual DOM，再将它和之前的 Virtual DOM 通过一个 diff 算法进行对比，将被改变的内容在浏览器中渲染，避免了 JS 引擎频繁调用渲染引擎的 DOM 操作接口，充分利用了 JS 引擎的性能。有了 Virtual DOM 的支持，React 也诞生了。
- 有了 React，「state => view」的思想也就有了很好的实践，但反过来呢，怎么在 view 中合理地修改 state 成为了一个新的问题，为此，Facebook 提出了 Flux 思想。

### Flux 思想
- Flux 不是某一个 JS 库的名称，而是一种架构思想，它用于构建客户端 Web 应用，规范数据在 Web 应用中的流动方式。
- Flux 的思维方式是单向的，将之前放权到各个组件的修改数据层的 controller 代码收归一处，统一管理，组件需要修改数据层的话需要去触发特定的预先定义好的 dispatcher，然后 dispatcher 将 action 应用到 model 上，实现数据层的修改。然后数据层的修改会应用到视图上，形成一个单向的数据流。
- 就和vuex差不多吧。。。原理上
- a simple demo
```
    const dispatcher = new Dispatcher()
    const store = {books: []}

    dispatcher.register((payload) => {
      if (payload.actionType === 'add-book') {
        store.books.push(payload.newBook)
      }
    })
    dispatcher.dispatch({
      actionType: 'add-book',
      newBook: {
        name: 'cookbook'
      }
    })
```

### vuex
- 首先，和 Redux 中使用不可变数据来表示 state 不同，Vuex 中没有 reducer 来生成全新的 state 来替换旧的 state，Vuex 中的 state 是可以被修改的。这么做的原因和 Vue 的运行机制有关系，Vue 基于 ES5 中的 getter/setter 来实现视图和数据的双向绑定，因此 Vuex 中 state 的变更可以通过 setter 通知到视图中对应的指令来实现视图更新。
- 另外，在 Vuex 中也可以记录每次 state 改变的具体内容，state 的变更可被记录与追踪。例如 Vue 的官方调试工具中就集成了 Vuex 的调试工具，使用起来和 Redux 的调试工具很相似，都可以根据某次变更的 state 记录实现视图快照
- 上面说到，Vuex 中的 state 是可修改的，而修改 state 的方式不是通过 actions，而是通过 mutations。一个 mutation 是由一个 type 和与其对应的 handler 构成的，type 是一个字符串类型用以作为 key 去识别具体的某个 mutation，handler 则是对 state 实际进行变更的函数。
- 一个完整数据流闭环，数据流的顺序如下：
在视图中触发 action，并根据实际情况传入需要的参数。
在 action 中触发所需的 mutation，在 mutation 函数中改变 state。
通过 getter/setter 实现的双向绑定会自动更新对应的视图。