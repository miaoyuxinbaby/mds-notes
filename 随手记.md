# 零碎知识点

- 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。

- 解构赋值的默认值是惰性求值，用到时才会求值

```js
let x;
{x} = {x: 1};

// 大括号写在行首会当成块级作用域。要用小括号() 包一下
// ({x} = {x: 1});
```

> 你工作中遇到过哪些困难？

- 不要迷恋 console 打印一个对象的时候，有时会出现属性是 `...` 需要点击才能查看，这是因为，console打印出来的是引用，值是会变化的

- 关于sort

```js
var str = 'abc'

[].sort.call(str)
// 报错
[].reduce.call(a, (acc, item) => acc + item + 'a')
// 正常运行
```

> 为了节约内存空间，javascript在排序时是采用的 `in-place` 的策略，就是在原数组的基础上，通过不断交换不同位置的元素来达到排序的目的。因为 **js中字符串是无法修改的**，那么sort内部对元素进行交换的操作就无法完成，所以使用Array.sort是无法对 `字符串` 排序的。

sort 大于10个元素的话用的是快排，少于10是插入排序. 选择插入排序是因为虽然时间复杂度很高，但在数据量很小的情况下很快

- NodeList, HTMLCollection之类的 [host objects] 无法修改，只能读取（实时变化）

vue-cli中的配置是这样的，img和css中 url() 写相对路径会被file-loader和url-loader处理， js中，数组的成员是图片路径，双向绑定后，低版本的话，img需要require(图片路径)来让webpack处理

Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。

:value 和 v-model可以一起用

平行组件通信可以用一个vue实例  在需要的地方import这个实例bus, 然后bus.$on 和 bus.$emit 配合传递数据  其实vuex应该也是基于这个原理的吧

类型注释和类型推断，ts和flow是注释，eslint是推断

import()是ecma的提案，require.ensure()是webpack的具体实现。

通过src属性加载的资源，浏览器限制了js的权限，使其不能读、写返回的内容。

如果没有同源策源，，可能a.com的一段js脚本，在b.com未曾加载此脚本时，也可以随意涂改b.com的页面。会让浏览器页面行为发生混乱