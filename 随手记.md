# 零碎知识点

- let,const,class声明的全局变量，不再是顶层对象windows的属性

- 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。

- 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。

- 解构赋值 等号的右边 必须是可遍历的结构，不然会报错

- 解构赋值的默认值是惰性求值，用到时才会求值

- 解构赋值 即模式匹配  模式:变量 = 模式:变量

- Promise.then() 里面return的值可以在下一个.then()中获取，通过参数

```js
let x;
{x} = {x: 1};

// 大括号写在行首会当成块级作用域。要用小括号() 包一下
// ({x} = {x: 1});
```

- 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。

```js
let { log, sin, cos } = Math;
```
- 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。
- 变量的解构赋值用途很多。大体有7种(阮一峰的es6书里)

  * 交换变量的值
  * 从函数返回多个值
  * 函数参数的定义
  * 函数参数的默认值
  * 提取JSON数据
  * 遍历Map结构
  * 从模块提取方法

```JS
// 交换变量的值
let x = 1;
let y = 2;

[x, y] = [y, x];

// 从函数返回多个值 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();

// 输入模块的指定方法
const { SourceMapConsumer, SourceNode } = require("source-map");
```

> 去除csdn广告

```js
[].forEach.call($("iframe"), item => item.remove());
[].forEach.call($(".btn-remove,.btn-close"), item => item.click())
```

- Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

> 你工作中遇到过哪些困难？

- 在对一个数组遍历时splice其成员，会有一些问题，我当时的解决方法是，splice原值，插入一个空值，遍历结束后，删除空值

- 不要迷恋 console 打印一个对象的时候，有时会出现属性是 `...` 需要点击才能查看，这是因为，console打印出来的是引用，值是会变化的

- iview的tabel组件性能有问题，可能是内部deepcopy的原因，总之非常不好用（不分页，200行数据以上，需要动态增删时）

- 关于sort

```js
var str = 'abc'

[].sort.call(str)
// 报错
[].reduce.call(a, (acc, item) => acc + item + 'a')
// 正常运行
```

> 为了节约内存空间，javascript在排序时是采用的 `in-place` 的策略，就是在原数组的基础上，通过不断交换不同位置的元素来达到排序的目的。因为 **js中字符串是无法修改的**，那么sort内部对元素进行交换的操作就无法完成，所以使用Array.sort是无法对 `字符串` 排序的。

sort 大于20个元素的话用的是快排，少于20是插入排序（应该是插入排序）

- NodeList, HTMLCollection之类的 [host objects] 无法修改，只能读取（实时变化）

- forEach（）无法在所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach（）方法放在一个try块中，并能抛出一个异常。如果forEach（）调用的函数抛出foreach.break异常，循环会提前终止.
- map,forEach,filter之类的方法都无法手动跳出循环，需要跳的话，就手写for,while之类的循环