# 零碎知识点

- let,const,class声明的全局变量，不再是顶层对象windows的属性

- 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。

- 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。

- 解构赋值 等号的右边 必须是可遍历的结构，不然会报错

- 解构赋值的默认值是惰性求值，用到时才会求值

- 解构赋值 即模式匹配  模式:变量 = 模式:变量

- Promise.then() 里面return的值可以在下一个.then()中获取，通过参数

```js
let x;
{x} = {x: 1};

// 大括号写在行首会当成块级作用域。要用小括号() 包一下
// ({x} = {x: 1});
```

- 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。

```js
let { log, sin, cos } = Math;
```

- 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。
- 变量的解构赋值用途很多。大体有7种(阮一峰的es6书里)

> 交换变量的值
> 从函数返回多个值
> 函数参数的定义
> 函数参数的默认值
> 提取JSON数据
> 遍历Map结构
> 从模块提取方法

```JS
// 交换变量的值
let x = 1;
let y = 2;

[x, y] = [y, x];

// 从函数返回多个值 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();

// 输入模块的指定方法
const { SourceMapConsumer, SourceNode } = require("source-map");
```

> 去除csdn广告

```js
[].forEach.call($("iframe"), item => item.remove());
[].forEach.call($(".btn-remove,.btn-close"), item => item.click())
```

- Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

> 你工作中遇到过哪些困难？

- 在对一个数组遍历时splice其成员，会有一些问题，我当时的解决方法是，splice原值，插入一个空值，遍历结束后，删除空值

- 不要迷恋 console 打印一个对象的时候，有时会出现属性是 `...` 需要点击才能查看，这是因为，console打印出来的是引用，值是会变化的

- iview的tabel组件性能有问题，可能是内部deepcopy的原因，总之非常不好用（不分页，200行数据以上，需要动态增删时）

- 关于sort

```js
var str = 'abc'

[].sort.call(str)
// 报错
[].reduce.call(a, (acc, item) => acc + item + 'a')
// 正常运行
```

> 为了节约内存空间，javascript在排序时是采用的 `in-place` 的策略，就是在原数组的基础上，通过不断交换不同位置的元素来达到排序的目的。因为 **js中字符串是无法修改的**，那么sort内部对元素进行交换的操作就无法完成，所以使用Array.sort是无法对 `字符串` 排序的。

sort 大于20个元素的话用的是快排，少于20是插入排序（应该是插入排序）

- NodeList, HTMLCollection之类的 [host objects] 无法修改，只能读取（实时变化）

- forEach（）无法在所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach（）方法放在一个try块中，并能抛出一个异常。如果forEach（）调用的函数抛出foreach.break异常，循环会提前终止.
- map,forEach,filter之类的方法都无法手动跳出循环，需要跳的话，就手写for,while之类的循环

> 关于vue-router 对于跳转当前路由（更新query)这类操作时, 不触发生命周期的一些钩子。（created和mounted)之类和渲染、初始化相关的。 

因为pc端经常需要有刷新页面和发送url给别人立马就能看到内容的应对之策，所以不适合用vuex和localstorage之类的本地存储，只能在url上传参。 如果在updated中重新请求数据，显然不合适（触发的时机太多，不可控）

这时候，有2种方法，第一：watch route，写case做判断。第二：vue-router2.2+ 可以用routerUpdate这个导航守卫。

在遇到，子路由的情况下，比如，Main和sidebar， 有时路由query变化的时候，需要对sidebar进行一些控制，比如说：sidebar是一个子路由的导航，要让他重定向到某个tab，

方法，暂时只想到了，在那个时候，调用sidebar的init方法（自定义的获取数据的方法+重定向），因为，有些参数变了，sidebar要传递的参数也就变了。如果sidebar是js控制的不谈，我这里说的是，sidebar渲染成a标签了。

要多思考，在这个没什么技术氛围的公司，只能靠自己通过思考来学习了，毕竟没有领路人。

Json的2个方法组合深拷贝缺点，，，函数无法被拷贝下来，同时也无法拷贝 copyObj 对象原型链上的属性和方法。循环引用也不能

iview的input组件，明明暴露了input事件，但却没有写进文档里。

File.__proto 是Blob。说明，file继承了blob.

```js
// 验证 File 继承 Blob
var file = new File(["foo"], "foo.txt", {
  type: "text/plain",
});

file instanceof Blob    // true
```

FileList对象是一个类数组对象，拥有 length 属性，对象的每个元素都是一个 File 对象实例